[1]. Guess the outputs of the following codes:
Ans:
===================================================
// Code 1:

function func1(){
  setTimeout(()=>{
    console.log(x);
    console.log(y);
  },3000);

  var x = 2;
  let y = 12;
}
func1();

Output--> 
Code 1 - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y.
====================================================

====================================================
//Code 2:
function func2(){
  for(var i = 0; i < 3; i++){
    setTimeout(()=> console.log(i),2000);
}
}
func2();

Output--> 
Code 2 - Outputs 3, three times since variable declared with var keyword does not have block scope. Also, inside the for loop, the variable i is incremented first and then checked.
====================================================

====================================================
// Code 3:

(function(){
  setTimeout(()=> console.log(1),2000);
  console.log(2);
  setTimeout(()=> console.log(3),0);
  console.log(4);
})();

Output--> 
2
4
3
1 // After two seconds
====================================================

[2]. Guess the outputs of the following code:
Ans
===================================================================
// Code 1:

let x= {}, y = {name:"Ronny"},z = {name:"John"};
x[y] = {name:"Vivek"};
x[z] = {name:"Akki"};
console.log(x[y]);

Output:
{name: “Akki”}.


In JavaScript, when objects are used as keys in another object, they are implicitly converted to strings. The default toString() method of objects is [object Object]. As a result, the keys x[y] and x[z] will both be converted to the same string "[object Object]", causing the latter assignment to overwrite the former one.

=====================================================================

=====================================================================
// Code 2:

function runFunc(){
  console.log("1" + 1);
  console.log("A" - 1);
  console.log(2 + "-2" + "2");
  console.log("Hello" - "World" + 78);
  console.log("Hello"+ "78");
}
runFunc();


Output--> 
11
Nan
2-22
NaN
Hello78
=======================================================================

=======================================================================
// Code 3:

let a = 0;
let b = false;
console.log((a == b));
console.log((a === b));

Output--> Output in the following order due to equality coercion:
true
false

___________________________________________________________________________________________________
___________________________________________________________________________________________________
[3]. Guess the output of the following code:
Ans

var x = 23;

(function(){
  var x = 43;
  (function random(){
    x++;
    console.log(x);
    var x = 21;
  })();
})(); 

Output--> NaN

random() function has functional scope since x is declared and hoisted in the functional scope.

Rewriting the random function will give a better idea about the output:
function random(){
  var x; // x is hoisted
  x++; // x is not a number since it is not initialized yet
  console.log(x); // Outputs NaN
  x = 21; // Initialization of x
}














