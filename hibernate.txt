What are the advantages of Hibernate over JDBC?
What are some of the important interfaces of Hibernate framework?
What is a Session in Hibernate?
What is a SessionFactory?
What do you think about the statement - “session being a thread-safe object”?
What is the difference between first level cache and second level cache?
What can you tell about Hibernate Configuration File?
How do you create an immutable class in hibernate?
Is hibernate prone to SQL injection attack?
Explain hibernate mapping file?
What are the most commonly used annotations available to support hibernate mapping?
Can you tell the difference between getCurrentSession and openSession methods?
What is criteria API in hibernate?
What does session.lock() method in hibernate do?
What is hibernate caching?
When is merge() method of the hibernate session useful?
Can you tell the difference between setMaxResults() and setFetchSize() of Query?
Does Hibernate support Native SQL Queries?
What happens when the no-args constructor is absent in the Entity bean?
Can we declare the Entity class final?
Can you tell something about the N+1 SELECT problem in Hibernate?




Ans:
Question: What are the advantages of Hibernate over JDBC?
Ans:
Clean and Readable Code:-Using Hibernate, helps in eliminating lots of JDBC-API boiler plate code, thereby making the code look cleaner and readable.

HQL(Hibernate Query Language):- It is closer to Java and is object-oriented in nature. This helps developers to write database independent queries. In JDBC, developers have to know database specific tables and fields.

Transaction Management:- JDBD does not provide implicit transaction management. Developers need to provide transaction code for begin, commit and rollback the transaction. But, Hibernate provides these features implicitly.

Exception Handling:-Hibernate throws unckecked Exceptions JDBCException or HIbernateException so, developers do not need to handle them.

Special Features:- Hibernate provides OOps features like associations, inheritence, and also supports collections. These are not available JDBC.



Question: What are some of the important interfaces of Hibernate framework?
Ans:
SessionFactory
Session
Transaction
Query
Criteria
Configuration


Question: What is a Session in Hibernate?
Ans:
Session is an object that maintains a connection between java object and database. Session has also methods for retrieving, storing, updating and deleting entities from database.
It provides various methods like persist(), find(), get(), save(), update(), delete() etc. It also has factor methods to return Query, Criteria and Transaction objects.


Question: What is a SessionFactory?
Ans:
SessionFactory provides Session object based on the configuration provided in order to connect to the database. 
It holds meta-data about class, queries and executions etc.
It holds second-level cache if enabled. 


Question: What do you think about the statement - “session being a thread-safe object”?
Ans:
No, Session is not a thread-safe object which means that any number of threads can access data from it simultaneously.


Question: What is the difference between first level cache and second level cache?
Ans:
First Level Cache:-This is local to the Session object and can not be shared between multiple sessions.
SecondLevelCache:- This cache is maintained at SessionFactory level and shared among all sessions in Hibernate. 

FirstLevelCache:-This cache is enabled by default and there is no to disable it. 
SecondLevelCache:-This cache is disabled by default and we can enable it through configuration.

FirstLevelCache:-The FirstLevelCache is available until the session is open and it gets destroyed when session is closed. 
SecondLevelCache:-The SecondLevelCache is available through the application's lifecycle, it is only destroyed and recreated only when application is restarted. 

If an entity or object is loaded by calling the get() method then Hibernate first checked the first level cache, if it doesn’t find the object then it goes to the second level cache if configured. If the object is not found then it finally goes to the database and returns the object, if there is no corresponding row in the table then it returns null.


Question: What can you tell about Hibernate Configuration File?
Ans:
hibernate.cfg.xml  ----> By default, this file is placed under the src/main/resource folder.
The file contains database related configurations and session-related configurations.
Hibernate provides facility to provide hibernate configuration either using hibernate.cfg.xml or hibernate.properties file. 

hibernate.cfg.xml file contains information:-
---------------------------------------------
Database Connection details:- Driver class, URL, Username and Password. 
There must be one configuration file for each database. For example, for 2 databases, we have two configuration files. 
Properties: -Dialect, show-sql, second-level cache and mapping file names. 



Question: How do you create an immutable class in hibernate?
Ans:
If we are using xml file, 
	mutable=false.
If we are using annotations:-
	@Immutable
	
Question: Is hibernate prone to SQL injection attack?
Ans:
It is a serious vulnerability problem in web security where attacker can interfere in queries made by an application to its database by allowing users to see sensitive data. Attacker can also modify the data that may change the application behaviour. 
Hibernate does not provide immunity to sql injection. However, following good practice can avoid this situation:---
1) Use Prepared Statements that use Parameterized Queries. 	(Using Named Parameter)
2) Use Stored Procedures
3) Ensure Data Sanity using Input validation

 

Question: Explain hibernate mapping file?
Ans:
Hibernate mapping file is an XML file that is used for defining the entity bean fields and corresponding database column mappings.
These files are useful when the project uses third-party classes where JPA annotations provided by hibernating cannot be used.

<hibernate-mapping>
   <!-- What class is mapped to what database table-->
  <class name = "InterviewBitEmployee" table = "InterviewBitEmployee">

     <meta attribute = "class-description">
        This class contains the details of employees of InterviewBit. 
     </meta>

     <id name = "id" type = "int" column = "employee_id">
        <generator class="native"/>
     </id>

     <property name = "fullName" column = "full_name" type = "string"/>
     <property name = "email" column = "email" type = "string"/>

  </class>
</hibernate-mapping>



Question: What are the most commonly used annotations available to support hibernate mapping?
Ans:
Hibernate framework provides support to JPA annotations and other useful annotations in the org.hibernate.annotations package. 

javax.persistence.Entity:- @Entity

javax.persistence.Table:- @Table

javax.persistence.Access:-It defines strategy to access properties of an entity. 
	It can be used in two ways:-
		@Access(AccessType.FIELD):- Hibernate will access entity directly through the fields. 
					    Field should be declared as package-private(default) or private for encapsulation.
					    Getters and Setters are not used, instead Hibernate access fields directly. 
					    
		@Access(AccessType.PROPERTY):- Hibernate will access state of the entity through getters and setters. So, we need to specify getters and setters. 
		
@Id:- To indicate that a particular attribute is primary key. 

@GeneratedValue

@EmbeddedId:- It is used upon attribute to indicate that the attribute is composite primary key.

@Column

@OneToOne, @OneToMany etc

@Cascade


@Entity
@Table(name = "InterviewBitEmployee")
@Access(value=AccessType.FIELD)
public class InterviewBitEmployee {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = "employee_id")
   private long id;

   @Column(name = "full_name")
   private String fullName;

   @Column(name = "email")
   private String email;
   
   @OneToOne(mappedBy = "employee")
   @Cascade(value = org.hibernate.annotations.CascadeType.ALL)
   private Address address;

   //getters and setters methods
}



Question: Can you tell the difference between getCurrentSession and openSession methods?
Ans:
getCurrentSession():-This method returns session bound to context.
openSession():-This method always open a new session.

getCurrentSession():-To make this work, hibernate configuration file has to be modified by adding <property neme="hibernate.current_session_context_class">thread</proprerty>. If not added, it will throw HibernateException.
openSession():-Any new session is to created for each request in multi-threaded environment. We don't need to add property.

getCurrentSession():-This session object gets closed once the session factory is closed. 
openSession():-It is developer's responsibility to close this object once all the database operations are done. 

getCurrentSession():- If we are using Hibernate in single-threaded environment, we can use getCurrentSession(), which is faster than generating a new session each time. 


Question: What is criteria API in hibernate?
Ans:
Criteria API helps to develop dynamic criteria queries. Criteria Query is more powerful and flexible than HQL query to create dynamic query. 
It can also use restrictions while querying data from database. 

Criteria criteria = session.createCriteria(EntityClass.class);
List<EntityClass> results = criteria.list();

To fetch all recoreds with name 'Hibernate':-
----------------------------------------------------
Criteria criteria = session.createCriteria(EntityClass.class);
criteria.add(Restriction.eq("fullName","Hibernate"));
List<EntityClass> results = criteria.list();

To get objects whose property has the value “not equal to” the restriction, we use Restrictions.ne() method. For example, to fetch all the records whose employee’s name is not Hibernate:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Criteria criteria= session.createCriteria(InterviewBitEmployee.class);
criteria.add(Restrictions.ne("fullName","Hibernate"));
List<Employee> results = criteria.list()


To retrieve all objects whose property matches a given pattern, we use Restrictions.like() (for case sensitivenes) and Restrictions.ilike()(for case insensitiveness):-
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Criteria criteria= session.createCriteria(InterviewBitEmployee.class);
criteria.add(Restrictions.like("fullName","Hib%");
List<InterviewBitEmployee> results = criteria.list();

Note:- From Hibernate 5 onwards, function to return object of type Criteria is deprecated. Hibernate 5 has provided interfaces CriteriaBuilder and CriteriaQuery to serve the purpose. 

CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<EntityClass.class> criteriaQuery = builder.createQuery(EntityClass.class);


 

Question: What does session.lock() method in hibernate do?
Ans:
session.lock() is used to reattach the detached object to the session. session.lock() does not check for any data synchronization between database and the object in persistence context and hence this reattachment might lead to loss data synchronization.




Question: What is hibernate caching?
Ans:
Hibernate caching is the strategy for improving the application performance by pooling objects in the cache so that the queries are executed faster. Hibernate caching is particularly useful when fetching the same data multiple times. Rather than hitting the database, we can just access the data from the cache. 

Types Of Hibernate Caching:-
--------------------------------
First Level Cache:
------------------

Second Level Cache:
--------------------
	Some cache providers ---> EH cache, Swarm Cache, OS cache etc, JBoss cache etc.
	


Question: When is merge() method of the hibernate session useful?
Ans:
In hibernate, merge() method is used to update the state of an object in the persistent context with the state of a detached object. merge() method is particularly useful when dealing the objects which are not associated with any hibernate session. 

public static void main(String args[])
{
	Employee employee = null;
	try(Session session=HibernateUtil.getSessionFactory().openSession();){
		employee = session.get(Employee.class,1);       //This is persistent object
	}
	catch(Exception e){
		e.printStackTrace();
	}
	
	employee.setEmail("pk.m@gmail.com");			//This is transient object
	
	try(Session session=HibernateUtil.getSessionFactory().openSession();){
		Employee employee2 = session.get(Employee.class,1);
		session.beginTransaction();
		session.merge(employee);
		session.beginTransaction().commit();
	}
	catch(Exception e){
		e.printStackTrace();
	}



Question: Can you tell the difference between setMaxResults() and setFetchSize() of Query?
Ans:
setMaxResults() the function works similar to LIMIT in SQL. Here, we set the maximum number of rows that we want to be returned. This method is implemented by all database drivers.
setFetchSize() returns the rows with the certain amount. 


Question: Does Hibernate support Native SQL Queries?
Ans:
Yes, it does. Hibernate provides the createSQLQuery() method to let a developer call the native SQL statement directly and returns a Query object.
It is used when we don't want to use HQL, we want to use database specific query. 

Query query = session.createSQLQuery("select * from Employee e where e.firstName=:firstName")
	.addEntity(Employee.class);
	.setParameter("firstName","Hibernate");
List result = query.list();



Question: What happens when the no-args constructor is absent in the Entity bean?
Ans:
Hibernate framework internally uses Reflection API for creating entity bean instances when get() or load() methods are called. The method Class.newInstance() is used which requires a no-args constructor to be present. When we don't have this constructor in the entity beans, then hibernate fails to instantiate the bean and hence it throws HibernateException.



Question: Can we declare the Entity class final?
Ans:
No, we should not define the entity class final because hibernate uses proxy classes and objects for lazy loading of data and hits the database only when it is absolutely needed. This is achieved by extending the entity bean. If the entity class (or bean) is made final, then it cant be extended and hence lazy loading can not be supported.



Question: Can you tell something about the N+1 SELECT problem in Hibernate?
Ans:N+1 SELECT problem is due to the result of using lazy loading. N+1 SELECT problem is due to the result of using lazy loading














------------------------------------------------------------------------------------------------------------THE END--------------------------------------------------------------------------------------


































































