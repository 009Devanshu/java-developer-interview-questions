Question 1: What are the different data types present in javascript?
--------------------------------------------------------------------------------------
Ans:
1] Primitive types
-----------------------
=> String
=> Number - It represents a number and can be written with or without decimals.
	var x = 3; //without decimal
	var y = 3.6; //with decimal

=> BigInt - This data type is used to store numbers which are above the limitation of the Number data type. It can store large integers and is represented by adding “n” to an integer literal.	
	-const bigInt1 = 1234567890123456789012345678901234567890n;
   	-const bigInt2 = BigInt("9876543210987654321098765432109876543210");
	
=> Boolean
=> Undefined - When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined.
var x; // value of x is undefined
var y = undefined; // we can also set the value of a variable as undefined

=> Null - It represents a non-existent or a invalid value.
Example :
var z = null;

=> Symbol - It is new data type introduced in ES6 version of Javascript. It is used to generate a new and unique key. 
//Symbols
>  const sym1 = Symbol();
console.log('Symbol is 'sym1)
Output-- Symbol is Symbol()

> const sym1 = Symbol('My identifier');
console.log('Symbol is ',sym1);
Output: Symbol is Symbol('My identifier');

> const sym1 = new Symbol('My identifier');
console.log('Symbol is ',sym1);
Output: We will get error 
        Symbol is not a constructor. 
       
> const sym1 = Symbol('My identifier');
console.log('Type of symbol is ',typeof sym1);
Output: Type of symbol is symbol
That means type of symbol is primitive. 

> const sym1 = Symbol('My identifier');
const sym2 = Symbol('My identifier');
console.log(sym1===sym2); //false

> But
  const a = 'this is';
  const b = 'this is';
  console.log(a===b); //true
  
  Same will happen with other primitives like number, undefined, null etc. 
  console.log(null===null); //true
  console.log(undefined===undefined);//true
  if we don't have symbols in javascriptl, it was difficult to create unique keys using primitive data types. That's why symbol was introduced. 
  
> const k1 = Symbol();
  const k2 = Symbol();
  myObj={};
  myObj[k1]="Harry";
  myObj[k2]="Rohan";
  console.log(myObj);
  
  Output: {Symbol():"Harry",Symbol():"Rohan"}
  console.log(myObj[k1]);
  Output: "Harry"
  
> const k1 = Symbol('identifier for k1');
  const k2 = Symbol('for k2');
  myObj={};
  myObj[k1]="Harry";
  myObje[k2]="Rohan";
  console.log(myObj);
  Output: {Symbol('identifier for k1'):"Harry",Symbol('for k2'):"Rohan"}
  
> console.log(myObj);
  console.log(myObj[k1]);
  console.log(myObj[k2]);
  
  console.log(myObj.k2);//can not do this to get Rohan because it is same as myObj["k2"]
  Agar hamne dot(.) kar diya to wo Search karega k2 namak string ko. 
  It is same as --> console.log(myObj["k2"]); 
  So, we will get undefined. 
  
> const k1 = Symbol('identifier for k1');
  const k2 = Symbol('for k2');
  myObj={};
  myObj[k1]="Harry";
  myObj[k2]="Rohan";
  myObj["name"]="Good boy";
  
  for(key in myObj){
    console.log(key,myObj[key]);
  }
  Output: name Good boy
  For in for in loop, Symbols are ignored. 
  
> To convert Object into JSON
  console.log(JSON.stringify(myObj));
  Output: {"name":"Good boy"}
  So, Symbols are ignored. 
  
  
Note: typeof operator is used to find type. 
  typeof null //Returns "Object" (kind of a bug in javascript)
  
  
[2] Non-primitive types
Primitive data types can store only a single value. To store multiple and complex values, non-primitive data types are used.
Object - Used to store collection of data.

-------------------------------------------------------
/ Collection of data in key-value pairs

var obj1 = {
   x:  43,
   y:  "Hello world!",
   z: function(){
      return this.x;
   }
}
      
// Collection of data as an ordered list
     
var array1 = [5, "Hello", true, 4.1]; 
---------------------------------------------------------

Note- It is important to remember that any data type that is not a primitive data type, is of Object type in javascript.

_________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________

[2]  Explain Hoisting in javascript.
Ans:
Hoisting is the default behaviour of javascript where all the variable and function declarations are moved on top.
This means that irrespective of where the variables and functions are declared, they are moved on top of the scope. The scope can be both local and global.

Example 1:
hoistedVariable = 3;
console.log(hoistedVariable); // outputs 3 even when the variable is declared after it is initialized	
var hoistedVariable;

Example 2:
hoistedFunction();  // Outputs " Hello world! " even when the function is declared after calling

function hoistedFunction(){ 
  console.log(" Hello world! ");
} 


Example 3:
/ Hoisting takes place in the local scope as well
function doSomething(){
  x = 33;
  console.log(x);
  var x;
} 
doSomething(); // Outputs 33 since the local variable “x” is hoisted inside the local scope

Note - Variable initializations are not hoisted, only variable declarations are hoisted:
var x;
console.log(x); // Outputs "undefined" since the initialization of "x" is not hoisted
x = 23;

Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code:
"use strict";
x = 23; // Gives an error since 'x' is not declared
var x; 

_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
3. Why do we use the word “debugger” in javascript?

The debugger for the browser must be activated in order to debug the code. Built-in debuggers may be switched on and off, requiring the user to report faults. The remaining section of the code should stop execution before moving on to the next line while debugging.

_______________________________________________________________________________________________________________
_______________________________________________________________________________________________________________
4. Difference between “ == “ and “ === “ operators.
Ans:
Both are comparison operators. The difference between both the operators is that “==” is used to compare values whereas, “ === “ is used to compare both values and types.

Example:
var x = 2;
var y = "2";
(x == y)  // Returns true since the value of both x and y is the same
(x === y) // Returns false since the typeof x is "number" and typeof y is "string"

____________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________

[5] Difference between var, let and const. 
-----------------------------------------------------
Ans:
var: If we declare a variable from var, then we also declare it again with the same name, and if we want to reassign its value then we can do that too. 
let: If we declare a variable with let, then we can not declare it again with the same name, but we can re-assign its value. 
const: If we decalre a variable with const, then we can neither declare it again, nor can re-assign its value. 


Scope:- var has a function scope or global scope if declared outside any function, let has a block scope. A block is denoted by curly braces {}. This means that variables declared with let are limited in scope to the block in which they are defined.

// Example using var
function exampleVar() {
    if (true) {
        var x = 10;
    }
    console.log(x); // Outputs: 10
}

// Example using let
function exampleLet() {
    if (true) {
        let y = 20;
    }
    console.log(y); // ReferenceError: y is not defined
}
	
	
	
[6] Explain Implicit Type Coercion in javascript.
Ans:
Implicit type coercion in javascript is the automatic conversion of value from one data type to another. It takes place when the operands of an expression are of different data types.

=> String coercion
String coercion takes place while using the ‘ + ‘ operator. When a number is added to a string, the number type is always converted to the string type.

Example 1:
var x = 3;
var y = "3";
x + y // Returns "33" 

Example 2:
var x = 24;
var y = "Hello";
x + y   // Returns "24Hello"; 

When JavaScript sees that the operands of the expression x + y are of different types ( one being a number type and the other being a string type ), it converts the number type to the string type and then performs the operation. Since after conversion, both the variables are of string type, the ‘ + ‘ operator outputs the concatenated string “33” in the first example and “24Hello” in the second example.

Note - Type coercion also takes place when using the ‘ - ‘ operator, but the difference while using ‘ - ‘ operator is that, a string is converted to a number and then subtraction takes place.

var x = 3;
Var y = "3";
x - y    //Returns 0 since the variable y (string type) is converted to a number type	
	
=> Boolean Coercion
All values except false, 0, 0n, -0, “”, null, undefined, and NaN are truthy values.

If statements:
Example:
-----------
var x = 0;
var y = 23;
        
if(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  
        
if(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy)	
	
Logical operators:
Logical operators in javascript, unlike operators in other programming languages, do not return true or false. They always return one of the operands.

OR ( | | ) operator - If the first value is truthy, then the first value is returned. Otherwise, always the second value gets returned.

AND ( && ) operator - If both the values are truthy, always the second value is returned. If the first value is falsy then the first value is returned or if the second value is falsy then the second value is returned.

Example:
--------------
var x = 220;
var y = "Hello";
var z = undefined;
        
x | | y    // Returns 220 since the first value is truthy
        
x | | z   // Returns 220 since the first value is truthy
        
x && y    // Returns "Hello" since both the values are truthy
        
y && z   // Returns undefined since the second value is falsy
        
if( x && y ){ 
  console.log("Code runs" ); // This block runs because x && y returns "Hello" (Truthy)
}   
        
if( x || z ){
  console.log("Code runs");  // This block runs because x || y returns 220(Truthy)
}
	
=> Equality Coercion
Equality coercion takes place when using ‘ == ‘ operator. 

___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________
[7]. Is javascript a statically typed or a dynamically typed language?	
Ans:
JavaScript is a dynamically typed language. In a dynamically typed language, the type of a variable is checked during run-time in contrast to a statically typed language, where the type of a variable is checked during compile-time.

A variable that is assigned a number type can be converted to a string type:	
var a = 23;
var a = "Hello World!";

_____________________________________________________________________________________________________________________
Question on Nan is left
_____________________________________________________________________________________________________________________

[9] Explain passed by value and passed by reference.	
Ans:
In JavaScript, primitive data types are passed by value and non-primitive data types are passed by reference.

For understanding passed by value and passed by reference, we need to understand what happens when we create a variable and assign a value to it,
var x = 2;
In the above example, we created a variable x and assigned it a value of “2”. In the background, the “=” (assign operator) allocates some space in the memory, stores the value “2” and returns the location of the allocated memory space. Therefore, the variable x in the above code points to the location of the memory space instead of pointing to the value 2 directly.

Assign operator dealing with primitive types:
=================================================
var y = 234;
var z = y;
In the above example, the assign operator knows that the value assigned to y is a primitive type (number type in this case), so when the second line code executes, where the value of y is assigned to z, the assign operator takes the value of y (234) and allocates a new space in the memory and returns the address. Therefore, variable z is not pointing to the location of variable y, instead, it is pointing to a new location in the memory.
-----------------------------------------------------------------------------------
var y = #8454; // y pointing to address of the value 234

var z = y; 
     
var z = #5411; // z pointing to a completely new address of the value 234
     
// Changing the value of y
y = 23;
console.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z
------------------------------------------------------------------------------------
From the above example, we can see that primitive data types when passed to another variable, are passed by value. Instead of just assigning the same address to another variable, the value is passed and new space of memory is created.

Assign operator dealing with non-primitive types:
=================================================================
var obj = { name: "Vivek", surname: "Bisht" };
var obj2 = obj;

In the above example, the assign operator directly passes the location of the variable obj to the variable obj2. In other words, the reference of the variable obj is passed to the variable obj2.
------------------------------------------------------------------------------------
var obj = #8711;  // obj pointing to address of { name: "Vivek", surname: "Bisht" }
var obj2 = obj;
    
var obj2 = #8711; // obj2 pointing to the same address 

// changing the value of obj1
        
obj.name = "Akki";
console.log(obj2);
        
// Returns {name:"Akki", surname:"Bisht"} since both the variables are pointing to the same address.
---------------------------------------------------------------------------------------
From the above example, we can see that while passing non-primitive data types, the assigned operator directly passes the address (reference).

Therefore, non-primitive data types are always passed by reference.

___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________
[10]. What is an Immediately Invoked Function in JavaScript?
Ans:
An Immediately Invoked Function ( known as IIFE and pronounced as IIFY) is a function that runs as soon as it is defined.

Syntax of IIFE :
=====================
(function(){ 
  // Do something;
})();


While executing javascript code, whenever the compiler sees the word “function”, it assumes that we are declaring a function in the code. Therefore, if we do not use the first set of parentheses, the compiler throws an error because it thinks we are declaring a function, and by the syntax of declaring a function, a function should always have a name.
function() {
  //Do something;
}
// Compiler gives an error since the syntax of declaring a function is wrong in the code above.

To remove this error, we add the first set of parenthesis that tells the compiler that the function is not a function declaration, instead, it’s a function expression.

The second set of parenthesis:
====================================
(function (){
  //Do something;
})();
From the definition of an IIFE, we know that our code should run as soon as it is defined. A function runs only when it is invoked. If we do not invoke the function, the function declaration is returned:
(function (){
  // Do something;
})

// Returns the function declaration

Therefore to invoke the function, we use the second set of parenthesis.
	
______________________________________________________________________________________________________
______________________________________________________________________________________________________
[12]. Explain Higher Order Functions in javascript.	
Ans:
Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.

------------------------------------------------------------
Examples of higher-order functions:
======================================
function higherOrder(fn) {
  fn();
}
   
higherOrder(function() { console.log("Hello world") });  



function higherOrder2() {
  return function() {
    return "Do something";
  }
}      
var x = higherOrder2();
x()   // Returns "Do something"
____________________________________________________________________________________________________
____________________________________________________________________________________________________

[13] First-class Function
Ans
A programming language is said to have First-class functions when functions in that language are treated like any other variable. For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.

-----------------------------------------------------------
-----------------------------------------------------------
Examples
=============
Assigning a function to a variable
--------------------------------------

const foo = () => {
  console.log("foobar");
};
foo(); // Invoke it using the variable
// foobar



Passing a function as an argument
----------------------------------------
function sayHello() {
  return "Hello, ";
}
function greeting(helloMessage, name) {
  console.log(helloMessage() + name);
}
// Pass `sayHello` as an argument to `greeting` function
greeting(sayHello, "JavaScript!");
// Hello, JavaScript!

Note: The function that we pass as an argument to another function is called a callback function. sayHello() is a callback function.



Returning a function
------------------------------------
function sayHello() {
  return () => {
    console.log("Hello!");
  };
}

______________________________________________________________________________________________________________
______________________________________________________________________________________________________________
[13]. Explain “this” keyword.
Ans
The “this” keyword refers to the object that the function is a property of.


=============================================================
function doSomething() {
  console.log(this);
}
doSomething();

In the above code, the function is a property of which object?

Since the function is invoked in the global context, the function is a property of the global object.
Therefore, the output of the above code will be the global object. Since we ran the above code inside the browser, the global object is the window object.

Example 2:
-----------------------
var obj = {
    name:  "vivek",
    getName: function(){
    console.log(this.name);
  }
}
   
obj.getName();
In the above code, at the time of invocation, the getName function is a property of the object obj , therefore, this keyword will refer to the object obj, and hence the output will be “vivek”.

Example 3:
-------------------------
 var obj = {
    name:  "vivek",
    getName: function(){
    console.log(this.name);
  }
     
}
       
var getName = obj.getName;
       
var obj2 = {name:"akshay", getName };
obj2.getName();

The output will be “akshay”.
Although the getName function is declared inside the object obj, at the time of invocation, getName() is a property of obj2, therefore the “this” keyword will refer to obj2.

______________________________________________________________________________________________________
______________________________________________________________________________________________________
[15]. Explain call(), apply() and, bind() methods.
Ans
1=> call()
> It is a pre-defined method in javascript. 
> It can be used to invoke a method(function) with an owner object as an argument.

***********************************************
***********************************************
function sayHello(){
  return "Hello " + this.name;
}
var obj = {name: "Sandy"};
        
sayHello.call(obj);
        
// Returns "Hello Sandy"	


> With call(), an object can use a method belonging to another object.
var person = {
  age: 23,
  getAge: function(){
    return this.age;
  }
}        
var person2 = {age:  54};
person.getAge.call(person2);      
// Returns 54  

> The call() Method with Arguments
The call() method can accept arguments

const person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}

const person1 = {
  firstName:"John",
  lastName: "Doe"
}

person.fullName.call(person1, "Oslo", "Norway");

************************************************************************
************************************************************************

2=> apply()
The apply method is similar to the call() method. The only difference is that,
call() method takes arguments separately whereas, apply() method takes arguments as an array.

**********************************************************
function saySomething(message){
  return this.name + " is " + message;
}        
var person4 = {name:  "John"};
saySomething.apply(person4, ["awesome"]);
***********************************************************


3=> bind()
This method returns a new function, where the value of “this” keyword will be bound to the owner object, which is provided as a parameter.

**************************************************************
var bikeDetails = {
    displayDetails: function(registrationNumber,brandName){
    return this.name+ " , "+ "bike details: "+ registrationNumber + " , " + brandName;
  }
}
   
var person1 = {name:  "Vivek"};
     
var detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, "TS0122", "Bullet");
      
// Binds the displayDetails function to the person1 object
        
      
detailsOfPerson1();
//Returns Vivek, bike details: TS0122, Bullet
*****************************************************************
__________________________________________________________________________________________________
__________________________________________________________________________________________________

[16]. What is the difference between exec () and test () methods in javascript?
Ans
=> test () and exec () are RegExp expression methods used in javascript. 
We'll use exec () to search a string for a specific pattern, and if it finds it, it'll return the pattern directly; else, it'll return null.

//////////////////////////////////////////////////////
Example
------------
Search a string for the character "e":
let text = "The best things in life are free";
let result = /e/.exec(text);	//e

Example
-------------
let text = "Hello world!";

// Look for "Hello"
let result1 = /Hello/.exec(text);  //Hello

// Look for "W3Schools"
let result2 = /W3Schools/.exec(text);  //null
 
=> We will use a test () to find a string for a specific pattern. It will return the Boolean value 'true' on finding the given text otherwise, it will return 'false'.

////////////////////////////////////////////////////////
Example 1:
---------------
let text = "The best things in life are free"; let pattern = /e/;
let result = pattern.test(text);  //true

Example 2:
-----------------
// The string:
let text = "Hello world!";

// Look for "Hello"
let pattern1 = /Hello/;
let result1 = pattern1.test(text);
console.log(result1); //true

// Look for "W3Schools"
let pattern2 = /W3Schools/;
let result2 = pattern2.test(text);
console.log(result2);  //false

/////////////////////////////////////////////////////////////////

___________________________________________________________________________________________________________
___________________________________________________________________________________________________________

[17]. What is currying in JavaScript?
Ans:
At its core, currying is a functional programming technique that involves breaking down a function that takes multiple arguments into a series of functions that take one argument each. This creates a chain of functions, where each function returns another function until the final result is achieved.

Advantages of function Currying in JavaScript
--------------------------------------------------
1-Reusability: Currying breaks down a complex function into smaller, reusable units. Each curried function focuses on a single argument, making it easier to understand and maintain. These smaller functions can be reused across different parts of your codebase.


=================================================================================
//Now let's make this same add function as a Currying function.
function add(num1) {
  return function (num2) {
    return function (num3) {
      return num1 + num2 + num3;
    };
  };
}
const result = add(5)(10)(15);
console.log(result);

const result1 = add(5);
console.log(result1);
// Output
// ƒ (num2) {
//   return function (num3) {
//     return num1 + num2 + num3;
//   };
// }
const result2 = result1(10);
console.log(result2);
// Output
// ƒ (num3) {
//   return num1 + num2 + num3;
// }
const result3 = result2(15);
console.log(result3); //30






Here's how the currying works step by step:


add(5) returns a function that takes the second number.
add(5)(10) / result1(10) returns a function that takes the third number.
add(5)(10)(15) returns the final result, which is the sum of all three numbers.
This way, you can call the curried add function with each argument separately, creating a more modular and composable function.
=====================================================================================
=====================================================================================
Currying using ES6 syntax in JavaScript:
const add = num1=>num2=>num3=>num1+num2+num3;

const result = add(5)(10)(15);
console.log(result);
======================================================================================
======================================================================================
Real life use case of Currying by accessing elements from a Object.
//curried function to access a property of an object
function prop(obj) {
  return function (key) {
    return obj[key];
  };
}

//sample user object
const user = {
  name: "Alice",
  age: 30,
};

//create curried function to access user properties
const accessUser = prop(user);

const userName = accessUser("name");
const userAge = accessUser("age");

console.log(userName + " " + userAge);
==============================================================================

==============================================================================
Then What is Infinite Currying?
In the following code we have converted the function to have infinite argument using some recursive nature as well. This allows you to create an infinite currying chain, where you can keep adding numbers as needed, and when you're ready to get the final result, just call the curried function with no arguments to compute the sum.

function add(num1) {
  return function (num2) {
    if (num2) {
      return add(num1 + num2);
    }
    return num1;
  };
}

const result = add(5)(6)();
console.log(result);



Here's how the code works:
The add function is defined to accept a single argument num1.
Inside the add function, an inner function is returned. This inner function takes an argument num2.
If num2 is provided (i.e., it's truthy), the inner function returns a recursive call to add with the sum of num1 and num2.
If num2 is not provided (i.e., it's falsy, like undefined or 0), the inner function returns the accumulated num1.
When the curried add function is called, it can be immediately invoked with the next argument, and this process can be repeated for as many arguments as needed.
The final invocation of the curried add function is done with an empty set of parentheses (). This results in computing the accumulated sum of all previously provided numbers.
The result is 11, which is the sum of 5 and 6.

___________________________________________________________________________________________________________
___________________________________________________________________________________________________________

[19]. Explain Scope and Scope Chain in javascript.
Ans:
Scope in JS determines the accessibility of variables and functions at various parts of one’s code.

There are three types of scopes in JS:
-----------------------------------------
Global Scope
Local or Function Scope
Block Scope

------------------------------------------------------------
----------------------
Scope Chain 
----------------------
Let’s understand that using an example:
var y = 24;

function favFunction(){
  var x = 667;
  var anotherFavFunction = function(){
    console.log(x); // Does not find x inside anotherFavFunction, so looks for variable inside favFunction, outputs 667
  }

  var yetAnotherFavFunction = function(){
    console.log(y); // Does not find y inside yetAnotherFavFunction, so looks for variable inside favFunction and does not find it, so looks for variable in global scope, finds it and outputs 24
  }

  anotherFavFunction();
  yetAnotherFavFunction();
}
favFunction();

If the variable is not found in the global space as well, a reference error is thrown.
-----------------------------------------------------------

_________________________________________________________________________________________________________
_________________________________________________________________________________________________________
[20]. Explain Closures in JavaScript.
Ans:
Closures are an ability of a function to remember the variables and functions that are declared in its outer scope.



----------------------------------------
var Person = function(pName){
  var name = pName;

  this.getName = function(){
    return name;
  }
}

var person = new Person("Neelesh");
console.log(person.getName());	//Output==> Neelesh  //Here, getName function is remembering the value name. 

=>this is referring to the object person that we created using constructor(function) function. 
So, if we do 
console.log(person.name); //undefined
Because, name is not the property of person object.



But, 
var Person = function (pName) {
  this.name = pName;

  this.getName = function () {
    return this.name;
  };
};

var person = new Person("Neelesh");
console.log(person.getName());  //Neelesh
console.log(person.name);  //Neelesh
------------------------------------------




------------------------------------------------------
Let's understand closure by example--> 
function randomFunc(){
  var obj1 = {name:"Vivian", age:45};

  return function(){
    console.log(obj1.name + " is "+ "awesome"); // Has access to obj1 even when the randomFunc function is executed

  }
}

var initialiseClosure = randomFunc(); // Returns a function

initialiseClosure();  //Output==>  “Vivian is awesome"

When the function randomFunc() runs, it seems that the returning function is using the variable obj1 inside it:
Therefore randomFunc(), instead of destroying the value of obj1 after execution, saves the value in the memory for further reference. This is the reason why the returning function is able to use the variable declared in the outer scope even after the function is already executed.
This ability of a function to store a variable for further reference even after it is executed is called Closure.

--------------------------------------------------------

___________________________________________________________________________________________________
___________________________________________________________________________________________________

[22] What are object prototypes?
Ans:
A prototype is a blueprint of an object. The prototype allows us to use properties and methods on an object even if the properties and methods do not exist on the current object.
         
                   (properties and methods)
bike.prototype=======================================>anotherbike = new bike();


All javascript objects inherit properties from a prototype. For example,
= Date objects inherit properties from the Date prototype
= Math objects inherit properties from the Math prototype
= Array objects inherit properties from the Array prototype.
= On top of the chain is Object.prototype. Every prototype inherits properties and methods from the Object.prototype.


================================================================================
var arr = [];
arr.push(2);

console.log(arr); // Outputs [2]

In the code above, as one can see, we have not defined any property or method called push on the array “arr” but the javascript engine does not throw an error.

The reason is the use of prototypes. As we discussed before, Array objects inherit properties from the Array prototype.

The javascript engine sees that the method push does not exist on the current array object and therefore, looks for the method push inside the Array prototype and it finds the method.

Whenever the property or method is not found on the current object, the javascript engine will always try to look in its prototype and if it still does not exist, it looks inside the prototype's prototype and so on.

==================================================================================

_________________________________________________________________________________________________
_________________________________________________________________________________________________

[23]. What are callbacks?
Ans:
Functions that are used as an argument to another function are called callback functions. 

___________________________________________________________________________________________________
___________________________________________________________________________________________________
[24]. What are the types of errors in javascript?
Ans:
There are two types of errors in javascript.
1=> Syntax error. 
2=> Logical error : The application executes without problems in this case. However, the output findings are inaccurate. 

_______________________________________________________________________________________________________
_______________________________________________________________________________________________________

[25]. What is memoization?
Ans
Memoization is a form of caching where the return value of a function is cached based on its parameters. If the parameter of that function is not changed, the cached version of the function is returned.

Note- Memoization is used for expensive function calls but in the following example, we are considering a simple function for understanding the concept of memoization better.

=========================================================
function memoizedAddTo256() {
  let cache = {};
  return function (num) {
    if (num in cache) {
      console.log("Cached value");
      return cache[num];
    } else {
      cache[num] = 256 + num;
      return cache[num];
    }
  };
}
let memoizedFunc = memoizedAddTo256();

const x = memoizedFunc(20);
const y = memoizedFunc(20);
console.log(x, y);
===========================================================

____________________________________________________________________________________________________
____________________________________________________________________________________________________

Note: 
let aNum = {};
aNum[x] = 240;  //Here, x is the key. 
console.log(aNum[x]);  //240

If we do, 
console.log(aNum.x); //undefined
because, aNum.x is like aNum["x"]

____________________________________________________________________________________________________
____________________________________________________________________________________________________
[27]. What is the use of a constructor function in javascript?
Ans
Constructor functions are used to create objects in javascript.
If we want to create multiple objects having similar properties and methods, constructor functions are used.

========================================================
function Person(name,age,gender){
  this.name = name;
  this.age = age;
  this.gender = gender;
}


var person1 = new Person("Vivek", 76, "male");
console.log(person1);

var person2 = new Person("Courtney", 34, "female");
console.log(person2);
==========================================================

__________________________________________________________________________________________________________
__________________________________________________________________________________________________________
[28]. What is DOM?
Ans:
=> DOM stands for Document Object Model.  DOM is a programming interface for HTML and XML documents.
=> When the browser tries to render an HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document.

__________________________________________________________________________________________________________
__________________________________________________________________________________________________________
[29]. Which method is used to retrieve a character from a certain index?
Ans:
The charAt() function of the JavaScript string finds a char element at the supplied index. The index number begins at 0 and continues up to n-1, Here n is the string length.

__________________________________________________________________________________________________________
__________________________________________________________________________________________________________
[30]. What do you mean by BOM?
Ans
Browser Object Model is known as BOM. It allows users to interact with the browser


___________________________________________________________________________________________________________
___________________________________________________________________________________________________________
[31]. What are arrow functions?
Ans
==========================================================
var obj1 = {
  valueOfThis: function(){
    return this;
  }
}
var obj2 = {
  valueOfThis: ()=>{
    return this;
  }
}

obj1.valueOfThis(); // Will return the object obj1
obj2.valueOfThis(); // Will return window/global object



The biggest difference between the traditional function expression and the arrow function is the handling of this keyword. By general definition, this keyword always refers to the object that is calling the function. As you can see in the code above, obj1.valueOfThis() returns obj1 since this keyword refers to the object calling the function.

In the arrow functions, there is no binding of this keyword. This keyword inside an arrow function does not refer to the object calling it. It rather inherits its value from the parent scope which is the window object in this case. Therefore, in the code above, obj2.valueOfThis() returns the window object.


============================================================

__________________________________________________________________________________________________________
__________________________________________________________________________________________________________

[32]. What do mean by prototype design pattern?
Ans
The Prototype Design Pattern in JavaScript is a creational design pattern that is used for creating objects based on a prototype of an existing object through cloning. 
The Prototype Pattern produces different objects, but instead of returning uninitialized objects, it produces objects that have values replicated from a template – or sample – object.

===============================================================
// Define a prototype object
const carPrototype = {
  brand: 'Toyota',
  model: 'Corolla',
  year: 2022,

  // Method to describe the car
  describe() {
    return `${this.brand} ${this.model} (${this.year})`;
  },

  // Method to clone the object
  clone() {
    // Create a new object with the same prototype
    const clone = Object.create(this);

    // Optionally, you can customize the cloned object
    // clone.someProperty = someValue;

    return clone;
  }
};

// Create a new car using the prototype
const car1 = carPrototype.clone();
console.log(car1.describe()); // Output: Toyota Corolla (2022)

// Customize the cloned object
car1.year = 2023;
console.log(car1.describe()); // Output: Toyota Corolla (2023)

// Create another car using the prototype
const car2 = carPrototype.clone();
console.log(car2.describe()); // Output: Toyota Corolla (2022)

======================================================================

___________________________________________________________________________________________
___________________________________________________________________________________________

[4]. What is the rest parameter and spread operator?
Ans
1=> Rest parameter ( … ):
Using the rest parameter syntax, we can create functions that can take a variable number of arguments.
Any number of arguments will be converted into an array using the rest parameter.
============================================================
function extractingArgs(...args){
  return args[1];
}

// extractingArgs(8,9,1); // Returns 9

function addAllArgs(...args){
  let sumOfArgs = 0;
  let i = 0;
  while(i < args.length){
    sumOfArgs += args[i];
    i++;
  }
  return sumOfArgs;
}

addAllArgs(6, 5, 7, 99); // Returns 117
addAllArgs(1, 3, 4); // Returns 8
====================================================================================

====================================================================================
**Note- Rest parameter should always be used at the last parameter of a function:
/ Incorrect way to use rest parameter
function randomFunc(a,...args,c){
//Do something
}

// Correct way to use rest parameter
function randomFunc2(a,b,...args){
//Do something
}
=====================================================================================

2=> spread operator (...)
spread operator is used to spreading an array, and object.

===================================================================
function addFourNumbers(num1,num2,num3,num4){
  return num1 + num2 + num3 + num4;
}

let fourNumbers = [5, 6, 7, 8];


addFourNumbers(...fourNumbers);
// Spreads [5,6,7,8] as 5,6,7,8

let array1 = [3, 4, 5, 6];
let clonedArray1 = [...array1];
// Spreads the array into 3,4,5,6
console.log(clonedArray1); // Outputs [3,4,5,6]


let obj1 = {x:'Hello', y:'Bye'};
let clonedObj1 = {...obj1}; // Spreads and clones obj1
console.log(obj1);

let obj2 = {z:'Yes', a:'No'};
let mergedObj = {...obj1, ...obj2}; // Spreads both the objects and merges it
console.log(mergedObj);
// Outputs {x:'Hello', y:'Bye',z:'Yes',a:'No'};
====================================================================

__________________________________________________________________________________________________
__________________________________________________________________________________________________
[5]. In JavaScript, how many different methods can you make an object?
Ans
In JavaScript, there are several ways to declare or construct an object.
1=>Object Literal
--------------------------
const obj = { key: value };

2=>Constructor Function:
------------------------------

function Car(brand, model) {
    this.brand = brand;
    this.model = model;
}
const car = new Car('Toyota', 'Corolla');

3=>Object.create()
--------------------------
const obj = Object.create(proto);

4=>Class Syntax
----------------------
class Car {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }
}
const car = new Car('Toyota', 'Corolla');

5=>Factory Function
--------------------------
function createCar(brand, model) {
    return {
        brand: brand,
        model: model,
        describe() {
            return `${this.brand} ${this.model}`;
        }
    };
}

const car = createCar('Toyota', 'Corolla');

_________________________________________________________________________________________________
_________________________________________________________________________________________________

[6]. What is the use of promises in javascript?
Ans
Promises are used to handle asynchronous operations in javascript.
Promise object has four states -
=> Pending - Initial state of promise. This state represents that the promise has neither been fulfilled nor been rejected, it is in the pending state.
=> Fulfilled - This state represents that the promise has been fulfilled, meaning the async operation is completed.
=> Rejected - This state represents that the promise has been rejected for some reason, meaning the async operation has failed.
=> Settled - This state represents that the promise has been either rejected or fulfilled.

A promise is created using the Promise constructor which takes in a callback function with two parameters, resolve and reject respectively.
=> new Promise();
resolve()==> Go to next action
reject()==> Handle error

=================================================================
function sumOfThreeElements(...elements){
  return new Promise((resolve,reject)=>{
    if(elements.length > 3 ){
      reject("Only three elements or less are allowed");
    }
    else{
      let sum = 0;
      let i = 0;
      while(i < elements.length){
        sum += elements[i];
        i++;
      }
      resolve("Sum has been calculated: "+sum);
    }
  })
}

const xx = sumOfThreeElements(10, 20, 30);
console.log(xx);
Output:-
Promise {<fulfilled>: 'Sum has been calculated 60'}
=====================================================================

We can consume any promise by attaching then() and catch() methods to the consumer.

then() method is used to access the result when the promise is fulfilled.

catch() method is used to access the result/error when the promise is rejected. In the code below, we are consuming the promise:

======================================================================
sumOfThreeElements(4, 5, 6)
.then(result=> console.log(result))
.catch(error=> console.log(error));
// In the code above, the promise is fulfilled so the then() method gets executed
======================================================================
___________________________________________________________________________________________________
___________________________________________________________________________________________________
[7]. What are classes in javascript?
Ans
Introduced in the ES6 version, classes are nothing but syntactic sugars for constructor functions. They provide a new way of declaring constructor functions in javascript. 

============================================================
// Before ES6 version, using constructor functions
function Student(name,rollNumber,grade,section){
  this.name = name;
  this.rollNumber = rollNumber;
  this.grade = grade;
  this.section = section;
}

// Way to add methods to a constructor function
Student.prototype.getDetails = function(){
  return `Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}`;
}


let student1 = new Student("Vivek", 354, "6th", "A");
student1.getDetails();
// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A
=========================================================================

=========================================================================
This is also correct==> 
// Before ES6 version, using constructor functions
function Student(name, rollNumber, grade, section) {
  this.name = name;
  this.rollNumber = rollNumber;
  this.grade = grade;
  this.section = section;
  this.getDetails = function () {
    return `Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}`;
  };
}

let student1 = new Student("Vivek", 354, "6th", "A");
const x = student1.getDetails();
console.log(x);
Output==> Name: Vivek, Roll no: 354, Grade: 6th, Section:A
===========================================================================

===========================================================================
// ES6 version classes
class Student{
  constructor(name,rollNumber,grade,section){
    this.name = name;
    this.rollNumber = rollNumber;
    this.grade = grade;
    this.section = section;
  }

  // Methods can be directly added inside the class
  getDetails(){
    return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}';
  }
}

let student2 = new Student("Garry", 673, "7th", "C");
student2.getDetails();
// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C
===============================================================================
Key points to remember about classes:
=>Unlike functions, classes are not hoisted. A class cannot be used before it is declared.
=>A class can inherit properties and methods from other classes by using the extend keyword.
=>All the syntaxes inside the class must follow the strict mode(‘use strict’) of javascript. An error will be thrown if the strict mode rules are not followed.

_____________________________________________________________________________________________________
_____________________________________________________________________________________________________

[8]. What are generator functions?
Ans
Generator functions are special class of functions. 
They can be stopped midway and then continue from where they had stopped. 
Generator functions are declared with the function* keyword instead of the normal function keyword:
function* genFunc(){
  // Perform operation
}

In normal functions, we use the return keyword to return a value and as soon as the return statement gets executed, the function execution stops:
function normalFunc(){
  return 22;
  console.log(2); // This line of code does not get executed
}

In the case of generator functions, when called, they do not execute the code, instead, they return a generator object. This generator object handles the execution.
function* genFunc(){
  yield 3;
  yield 4;
}
genFunc(); // Returns Object [Generator] {}

The generator object consists of a method called next(), this method when called, executes the code until the nearest yield statement, and returns the yield value.

For example, if we run the next() method on the above code:
genFunc().next(); // Returns {value: 3, done:false}

As one can see the next method returns an object consisting of a value and done properties.  Value property represents the yielded value. Done property tells us whether the function code is finished or not. (Returns true if finished).

As one can see the next method returns an object consisting of a value and done properties.  Value property represents the yielded value. Done property tells us whether the function code is finished or not. (Returns true if finished).

Generator functions are used to return iterators. Let’s see an example where an iterator is returned:
function* iteratorFunc() {
  let count = 0;
  for (let i = 0; i < 2; i++) {
      count++;
      yield i;
  }
  return count;
}

let iterator = iteratorFunc();
console.log(iterator.next()); // {value:0,done:false}
console.log(iterator.next()); // {value:1,done:false}
console.log(iterator.next()); // {value:2,done:true}
As you can see in the code above, the last line returns done:true, since the code reaches the return statement.

__________________________________________________________________________________________________________
__________________________________________________________________________________________________________

[9]. Explain WeakSet in javascript.
Ans
In javascript, a Set is a collection of unique and ordered elements.  Just like Set, WeakSet is also a collection of unique and ordered elements with some key differences:
=> Weakset contains only objects and no other type.
=> An object inside the weakset is referenced weakly. This means, that if the object inside the weakset does not have a reference, it will be garbage collected.
=> Unlike Set, WeakSet only has three methods, add() , delete() and has() .

==================================================================
const newSet = new Set([4, 5, 6, 7]);
console.log(newSet);// Outputs Set {4,5,6,7}

const newSet2 = new WeakSet([3, 4, 5]); //Throws an error


let obj1 = {message:"Hello world"};
const newSet3 = new WeakSet([obj1]);
console.log(newSet3.has(obj1)); // true

==================================================================

____________________________________________________________________________________________________________
____________________________________________________________________________________________________________
[11]. Explain WeakMap in javascript.
Ans
In javascript, Map is used to store key-value pairs. The key-value pairs can be of both primitive and non-primitive types. WeakMap is similar to Map with key differences:

The keys and values in weakmap should always be an object.
If there are no references to the object, the object will be garbage collected.

==========================================================
const map1 = new Map();
map1.set('Value', 1);

const map2 = new WeakMap();
map2.set('Value', 2.3); // Throws an error

let obj = {name:"Vivek"};
const map3 = new WeakMap();
map3.set(obj, {age:23});
==========================================================

________________________________________________________________________________________________________
________________________________________________________________________________________________________
[12]. What is Object Destructuring?
Ans
Object destructuring is a way to extract elements from an object or an array.


=======================================================
=> Object destructuring: Before ES6 version:

const classDetails = {
  strength: 78,
  benches: 39,
  blackBoard:1
}

const classStrength = classDetails.strength;
const classBenches = classDetails.benches;
const classBlackBoard = classDetails.blackBoard;

========================================================


========================================================
=> The same example using object destructuring:

const classDetails = {
  strength: 78,
  benches: 39,
  blackBoard:1
}

const {strength:classStrength, benches:classBenches,blackBoard:classBlackBoard} = classDetails;

console.log(classStrength); // Outputs 78
console.log(classBenches); // Outputs 39
console.log(classBlackBoard); // Outputs 1
=========================================================

As one can see, using object destructuring we have extracted all the elements inside an object in one line of code. If we want our new variable to have the same name as the property of an object we can remove the colon:
const {strength} = classDetails;

=========================================================
Array destructuring: Before ES6 version:

const arr = [1, 2, 3, 4];
const first = arr[0];
const second = arr[1];
const third = arr[2];
const fourth = arr[3];
==========================================================

==========================================================
The same example using object destructuring:

const arr = [1, 2, 3, 4];
const [first,second,third,fourth] = arr;
console.log(first); // Outputs 1
console.log(second); // Outputs 2
console.log(third); // Outputs 3
console.log(fourth); // Outputs 4
===========================================================

_______________________________________________________________________________________________________
_______________________________________________________________________________________________________

[13]. Difference between prototypal and classical inheritance
Ans
A prototype serves as a template for other objects and are cloned via an object linking method Object.create(proto). 
======================================================
// Creating an object
let person = {
    name: 'John',
    age: 30,
    greet() {
        console.log('Hello, my name is ' + this.name);
    }
};

// Creating another object inheriting from 'person'
let student = Object.create(person);
student.major = 'Computer Science';

// Accessing properties and methods
console.log(student.name); // 'John'
student.greet(); // 'Hello, my name is John'
==================================================================

Classical inheritence is based on the concept of classes and is commanly associated with languages like java and c++.
In classical inheritence, class acts as a blueprint and define properties and behaviour whereas object is the real entity of a class.  and inheritance is achieved through class hierarchies.

==================================================================
JavaScript didn't support classical inheritance until the introduction of ES6 (ECMAScript 2015) with the class syntax. However, under the hood, it still uses prototypal inheritance.

// ES6 class syntax
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    greet() {
        console.log('Hello, my name is ' + this.name);
    }
}

// Inheriting from the Person class
class Student extends Person {
    constructor(name, age, major) {
        super(name, age);
        this.major = major;
    }
}

// Creating an object
let student = new Student('John', 30, 'Computer Science');

// Accessing properties and methods
console.log(student.name); // 'John'
student.greet(); // 'Hello, my name is John'
==================================================================

______________________________________________________________________________________________________
______________________________________________________________________________________________________
[14] What is a Temporal Dead Zone?
Ans
Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords. It is a behaviour where we initialize or access it before declaration. Examples of temporal dead zone:

===================================================
x = 23; // Gives reference error

let x;

function anotherRandomFunc(){
  message = "Hello"; // Throws a reference error

  let message;
}
anotherRandomFunc();
====================================================

________________________________________________________________________________________________________
________________________________________________________________________________________________________

[15] What is the role of deferred scripts in JavaScript?
Ans
When you include a script using the defer attribute in an HTML document, it tells the browser to download the script in the background while the rest of the page continues to load. his reduces the time it takes for web pages to load, allowing them to appear more quickly.



















